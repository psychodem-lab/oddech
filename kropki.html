<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Po≈ÇƒÖcz Kropki - Ukryj Podpowiedzi</title>
    <style>
        /* CSS: Ustawienia dla responsywno≈õci i wyglƒÖdu */
        :root {
            --color-primary: #007bff; 
            --color-success: #28a745; 
            --color-default: #6c757d; 
            --color-error: #dc3545;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            margin: 20px 10px;
            padding: 0;
            text-align: center;
        }
        header {
            background-color: #f4f4f9;
            color: white;
            padding: 5px 10px;
            text-align: center;
            width: 100%; 
        }
          .logo-wrapper a {
            text-decoration: none;
            border: none;
        }

        .logo-wrapper img {
            max-height: 100px; 
            width: auto;
            display: inline-block;
            margin-top: 0; 
            border: 0;
        }
        h1 {
            color: #333;
            margin-bottom: 5px;
        }

        /* Kontrola Poziom√≥w i Reset */
        #controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
            width: 90vw;
            max-width: 600px;
        }

        #levelSelect, #resetButton, #hintToggleContainer {
            padding: 10px;
            font-size: 1em;
            border-radius: 5px;
        }

        #levelSelect {
            border: 2px solid var(--color-primary);
        }

        #resetButton {
            background-color: var(--color-primary);
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #resetButton:hover {
            background-color: #0056b3;
        }

        /* Styl dla opcji ukrywania podpowiedzi */
        #hintToggleContainer {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            background-color: #e9ecef;
        }

        /* Sekcja Statystyk */
        #stats {
            display: flex;
            justify-content: space-around;
            width: 90vw;
            max-width: 600px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 8px;
        }

        .stat-item {
            font-size: 1.1em;
            font-weight: bold;
            color: #333;
        }

        .stat-value {
            color: var(--color-primary);
        }

        /* Ustawienie p≈Ç√≥tna jako responsywnego */
        canvas {
            max-width: 600px; 
            max-height: 400px;
            width: 90vw; 
            height: 60vw; 
            border: 2px solid var(--color-primary);
            background-color: white;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            touch-action: manipulation;
        }

        #info {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 1.1em;
            color: #333;
            font-weight: bold;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            min-height: 50px; 
            visibility: visible; /* Domy≈õlna widoczno≈õƒá */
            transition: visibility 0.2s, opacity 0.2s;
        }
        
        /* Klasa dodawana przez JS do ukrywania */
        .hidden-info {
            visibility: hidden;
            opacity: 0;
        }
    </style>
</head>
<body>
    <header>
  <div class="logo-wrapper">
            <a href="index.html" title="Powr√≥t do strony g≈Ç√≥wnej">
                <img src="logo.png" alt="Logo Psychodem">
            </a>
        </div>
    </header>

    <h1>Po≈ÇƒÖcz Kropki!</h1>
    <p id="sequenceInfo">Aktualna sekwencja: 1 ‚Üí 2 ‚Üí 3 ‚Üí ...</p>
    
    <div id="controls">
        <select id="levelSelect" onchange="resetGame()">
            <option value="easy">≈Åatwy (1 ‚Üí 20)</option>
            <option value="medium" selected>≈öredni (1, A, 2, B, ...)</option>
            <option value="hard">Trudny (1, A, 2, B, ..., 13)</option>
        </select>
        
        <div id="hintToggleContainer">
            <label for="hintToggle">Ukryj podpowiedzi (nazwƒô nastƒôpnego punktu i b≈Çƒôdy):</label>
            <input type="checkbox" id="hintToggle" onchange="toggleHints()">
        </div>

        <button id="resetButton" onclick="resetGame()">Zacznij nowƒÖ grƒô (Losuj punkty)</button>
    </div>

    <div id="stats">
        <div class="stat-item">
            Czas: <span id="timer" class="stat-value">00:00</span>
        </div>
        <div class="stat-item">
            B≈Çƒôdy: <span id="errors" class="stat-value" style="color: var(--color-error);">0</span>
        </div>
    </div>

    <canvas id="gameCanvas" width="600" height="400"></canvas>
    
    <div id="info">Wybierz poziom i kliknij (1), aby rozpoczƒÖƒá!</div>

    <script>
        // JavaScript: Logika Gry
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const infoDiv = document.getElementById('info');
        const timerSpan = document.getElementById('timer');
        const errorsSpan = document.getElementById('errors');
        const levelSelect = document.getElementById('levelSelect');
        const sequenceInfo = document.getElementById('sequenceInfo');
        const hintToggle = document.getElementById('hintToggle');

        // Wewnƒôtrzne wymiary Canvas
        const CANVAS_WIDTH = canvas.width;
        const CANVAS_HEIGHT = canvas.height;
        const POINT_RADIUS = 18;
        const FONT_SIZE = '16px';
        const MIN_DISTANCE = 2 * POINT_RADIUS + 30; 

        // --- DEFINICJE POZIOM√ìW ---
        const LEVELS = {
            easy: {
                count: 20,
                labels: Array.from({ length: 20 }, (_, i) => (i + 1).toString()),
                desc: "1 ‚Üí 2 ‚Üí 3 ‚Üí ... ‚Üí 20"
            },
            medium: {
                count: 15,
                labels: ['1', 'A', '2', 'B', '3', 'C', '4', 'D', '5', 'E', '6', 'F', '7', 'G', '8'],
                desc: "1 ‚Üí A ‚Üí 2 ‚Üí B ‚Üí ... ‚Üí 8"
            },
            hard: {
                count: 25,
                labels: [
                    '1', 'A', '2', 'B', '3', 'C', '4', 'D', '5', 'E', '6', 'F', '7', 'G', '8', 
                    'H', '9', 'I', '10', 'J', '11', 'K', '12', 'L', '13'
                ],
                desc: "1 ‚Üí A ‚Üí 2 ‚Üí B ‚Üí ... ‚Üí 13"
            }
        };

        // --- Zmienne Stanu Gry ---
        let timerInterval = null;
        let startTime = null;
        let errorCount = 0;
        let currentPointIndex = 0; 
        let connections = [];      
        let points = []; 
        let currentLevel = LEVELS['medium'];

        // --- Funkcje Ukrywania Podpowiedzi ---

        function toggleHints() {
            if (hintToggle.checked) {
                // Ukryj podpowiedzi
                infoDiv.classList.add('hidden-info');
            } else {
                // Poka≈º podpowiedzi
                infoDiv.classList.remove('hidden-info');
                // Je≈õli gra siƒô rozpoczƒô≈Ça, od≈õwie≈º komunikat
                if (currentPointIndex > 0 && currentPointIndex < points.length && timerInterval !== null) {
                    infoDiv.textContent = `Nastƒôpny punkt: (${points[currentPointIndex].label})`;
                }
            }
        }

        function updateInfoDisplay(message, isEndGame = false) {
            if (isEndGame || !hintToggle.checked) {
                // Zawsze pokazuj ko≈Ñcowy komunikat lub je≈õli podpowiedzi sƒÖ w≈ÇƒÖczone
                infoDiv.innerHTML = message;
                infoDiv.classList.remove('hidden-info');
            } else {
                // Je≈õli ukrywamy podpowiedzi, tylko wyczy≈õƒá/ukryj komunikat
                infoDiv.classList.add('hidden-info');
            }
        }

        // --- Funkcje Losowania ---

        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function generateRandomPoints() {
            const randomPoints = [];
            const labels = currentLevel.labels;
            
            const xMin = POINT_RADIUS;
            const xMax = CANVAS_WIDTH - POINT_RADIUS;
            const yMin = POINT_RADIUS;
            const yMax = CANVAS_HEIGHT - POINT_RADIUS;

            for (let i = 0; i < labels.length; i++) {
                let newPoint;
                let isTooClose;

                do {
                    const x = getRandomInt(xMin, xMax);
                    const y = getRandomInt(yMin, yMax);
                    
                    newPoint = { x: x, y: y, label: labels[i] };
                    isTooClose = false;
                    
                    for (const existingPoint of randomPoints) {
                        const distance = Math.sqrt(
                            Math.pow(newPoint.x - existingPoint.x, 2) + 
                            Math.pow(newPoint.y - existingPoint.y, 2)
                        );
                        
                        if (distance < MIN_DISTANCE) {
                            isTooClose = true;
                            break;
                        }
                    }
                } while (isTooClose); 

                randomPoints.push(newPoint);
            }
            return randomPoints;
        }

        // --- Funkcje Czasu ---
        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        function updateTimerDisplay() {
            if (startTime) {
                const currentTime = Math.floor((Date.now() - startTime) / 1000);
                timerSpan.textContent = formatTime(currentTime);
            }
        }
        function startTimer() {
            if (timerInterval !== null) return;
            startTime = Date.now();
            timerInterval = setInterval(updateTimerDisplay, 1000);
            updateInfoDisplay(`Start! Kliknij nastƒôpny punkt: (${points[currentPointIndex].label})`);
        }
        function stopTimer() {
            clearInterval(timerInterval);
            timerInterval = null;
        }

        // --- Funkcje Rysowania ---
        function draw() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-primary');
            ctx.lineWidth = 4;
            ctx.beginPath();
            connections.forEach(conn => {
                ctx.moveTo(conn.start.x, conn.start.y);
                ctx.lineTo(conn.end.x, conn.end.y);
            });
            ctx.stroke();
            ctx.closePath();

            points.forEach((point, index) => {
                const isConnected = index < currentPointIndex;

                ctx.fillStyle = isConnected 
                    ? getComputedStyle(document.documentElement).getPropertyValue('--color-success') 
                    : getComputedStyle(document.documentElement).getPropertyValue('--color-default');
                
                ctx.beginPath();
                ctx.arc(point.x, point.y, POINT_RADIUS, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'white'; 
                ctx.font = `${FONT_SIZE} Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(point.label, point.x, point.y);
            });
        }

        function drawFinalLine() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); 
            draw(); 
            
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-error'); 
            ctx.lineWidth = 6;
            ctx.beginPath();
            
            points.forEach((point, index) => {
                if (index === 0) {
                    ctx.moveTo(point.x, point.y);
                } else {
                    ctx.lineTo(point.x, point.y);
                }
            });
            
            ctx.stroke();
        }

        // --- Obs≈Çuga Interakcji ---

        function handleInteraction(event) {
            if (event.type === 'touchstart') {
                event.preventDefault();
            }

            if (timerInterval === null && currentPointIndex === points.length) {
                return; 
            }

            const rect = canvas.getBoundingClientRect();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;

            const clickX = clientX - rect.left;
            const clickY = clientY - rect.top;

            const scaleX = CANVAS_WIDTH / rect.width;
            const scaleY = CANVAS_HEIGHT / rect.height;

            const mouseX = clickX * scaleX;
            const mouseY = clickY * scaleY;

            const expectedPoint = points[currentPointIndex];
            
            // 1. Sprawd≈∫, czy klikniƒôto w oczekiwany punkt
            const distanceToExpected = Math.sqrt(
                Math.pow(mouseX - expectedPoint.x, 2) + Math.pow(mouseY - expectedPoint.y, 2)
            );

            if (distanceToExpected < POINT_RADIUS) {
                // POPRAWNE KLIKNIƒòCIE
                if (currentPointIndex === 0 && timerInterval === null) {
                    startTimer();
                }

                if (currentPointIndex > 0) {
                    const previousPoint = points[currentPointIndex - 1];
                    connections.push({ start: previousPoint, end: expectedPoint });
                }

                currentPointIndex++;

                if (currentPointIndex === points.length) {
                    stopTimer();
                    const finalTime = timerSpan.textContent;
                    
                    const finalMessage = `
                        <strong>GRATULACJE! Wszystkie punkty po≈ÇƒÖczone! ü•≥</strong><br>
                        Tw√≥j czas: <span style="color: var(--color-primary);">${finalTime}</span> | 
                        Liczba b≈Çƒôd√≥w: <span style="color: var(--color-error);">${errorCount}</span>
                    `;
                    updateInfoDisplay(finalMessage, true); // Zawsze pokazuj na koniec
                    
                    drawFinalLine();
                } else {
                    updateInfoDisplay(`Po≈ÇƒÖczono! Nastƒôpny: (${points[currentPointIndex].label})`);
                    draw();
                }
                return;
            } 
            
            // 2. Je≈õli nie klikniƒôto poprawnie, sprawd≈∫, czy klikniƒôto jakikolwiek inny punkt
            let clickedWrongPoint = false;
            if (currentPointIndex > 0 || timerInterval !== null) { 
                for(let i = 0; i < points.length; i++) {
                    const currentPoint = points[i];
                    
                    // Pomijamy ju≈º po≈ÇƒÖczone punkty i oczekiwany punkt
                    if (i < currentPointIndex) continue; 
                    if (i === currentPointIndex) continue;

                    const distance = Math.sqrt(
                        Math.pow(mouseX - currentPoint.x, 2) + Math.pow(mouseY - currentPoint.y, 2)
                    );

                    if (distance < POINT_RADIUS) {
                        clickedWrongPoint = true;
                        break;
                    }
                }
            }

            // 3. Je≈õli klikniƒôto w Z≈ÅY SYMBOL - nalicz b≈ÇƒÖd
            if (clickedWrongPoint) {
                errorCount++;
                errorsSpan.textContent = errorCount;
                const errorMessage = `B≈ÅƒÑD! Klikniƒôto z≈Çy symbol. Oczekiwany: (${expectedPoint.label}). B≈Çƒôdy: ${errorCount}`;
                updateInfoDisplay(errorMessage);
            } 
            // 4. W przeciwnym razie (klikniƒôto puste t≈Ço) - zignoruj
            else if (currentPointIndex > 0 || timerInterval !== null) {
                 const emptyMessage = `Puste t≈Ço. Kliknij symbol (${expectedPoint.label})`;
                 updateInfoDisplay(emptyMessage);
            }
        }
        
        // --- Funkcja Reset i Konfiguracja Gry ---
        function resetGame() {
            // Konfiguracja nowego poziomu
            const selectedLevelKey = levelSelect.value;
            currentLevel = LEVELS[selectedLevelKey];

            // Reset stanu
            stopTimer();
            startTime = null;
            errorCount = 0;
            currentPointIndex = 0;
            connections = [];

            // Generowanie nowych punkt√≥w dla wybranego poziomu
            points = generateRandomPoints();

            // Aktualizacja informacji o sekwencji
            sequenceInfo.textContent = `Aktualna sekwencja: ${currentLevel.desc}`;

            // Reset wy≈õwietlania
            timerSpan.textContent = '00:00';
            errorsSpan.textContent = '0';
            
            // Ustawienie poczƒÖtkowego komunikatu
            const startMessage = `Kliknij punkt startowy (${points[0].label}), aby rozpoczƒÖƒá!`;
            updateInfoDisplay(startMessage, true); // Zawsze pokazuj poczƒÖtkowy komunikat
            toggleHints(); // Stosuje ukrycie/pokazanie po resecie

            // Przerysowanie
            draw();
            
            // Ponowne w≈ÇƒÖczenie s≈Çuchaczy
            canvas.removeEventListener('click', handleInteraction);
            canvas.removeEventListener('touchstart', handleInteraction);
            canvas.addEventListener('click', handleInteraction);
            canvas.addEventListener('touchstart', handleInteraction);
        }

        // INICJALIZACJA GRY
        resetGame(); 
    </script>

</body>
</html>
