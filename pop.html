<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cicha Woda - Poprawione Bąbelki</title>
    <style>
        body { 
            background: #e3f2fd; 
            margin: 0; 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            font-family: 'Segoe UI', sans-serif;
            color: #0277bd;
        }
        canvas { 
            background: linear-gradient(to bottom, #4fc3f7, #0288d1); 
            box-shadow: 0 15px 45px rgba(0,0,0,0.2);
            border-radius: 25px;
            margin-top: 20px;
            cursor: crosshair;
            border: 8px solid white;
            max-width: 95vw;
            touch-action: none; /* Ważne dla urządzeń mobilnych */
        }
        .ui { text-align: center; padding: 15px; }
    </style>
</head>
<body>

<div class="ui">
    <h2 style="margin:5px">Pękające Bąbelki</h2>
    <p style="margin:0">Kliknij lub dotknij bąbelka, aby go rozbić.</p>
</div>

<canvas id="bubbleCanvas" width="800" height="550"></canvas>

<script>
    const canvas = document.getElementById("bubbleCanvas");
    const ctx = canvas.getContext("2d");

    let bubbles = [];
    let particles = []; // Efekty pękania

    // Funkcja tworząca bąbelek
    function createBubble() {
        if (bubbles.length < 40) {
            bubbles.push({
                x: Math.random() * canvas.width,
                y: canvas.height + 50,
                radius: 15 + Math.random() * 25,
                speed: 0.5 + Math.random() * 1,
                sway: Math.random() * 0.02,
                offset: Math.random() * 100
            });
        }
    }

    // Obsługa kliknięcia/dotyku
    canvas.addEventListener('pointerdown', function(e) {
        // Obliczanie pozycji względem canvasu (działa na PC i Mobile)
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const mouseX = (e.clientX - rect.left) * scaleX;
        const mouseY = (e.clientY - rect.top) * scaleY;

        // Sprawdzanie kolizji od końca (aby klikać te "na wierzchu")
        for (let i = bubbles.length - 1; i >= 0; i--) {
            const b = bubbles[i];
            const dx = mouseX - b.x;
            const dy = mouseY - b.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < b.radius) {
                // Stwórz cząsteczki pęknięcia
                createSplash(b.x, b.y, b.radius);
                // Usuń bąbelek
                bubbles.splice(i, 1);
                break; // Jeden klik rozbija jeden bąbelek
            }
        }
    });

    function createSplash(x, y, radius) {
        for (let i = 0; i < 8; i++) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 0.5) * 5,
                life: 1.0,
                color: 'rgba(255, 255, 255, 0.8)'
            });
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Rysowanie i aktualizacja bąbelków
        for (let i = bubbles.length - 1; i >= 0; i--) {
            const b = bubbles[i];
            b.y -= b.speed;
            b.x += Math.sin(b.y * b.sway + b.offset) * 0.8;

            // Rysowanie bąbelka
            ctx.beginPath();
            let grad = ctx.createRadialGradient(b.x - b.radius*0.3, b.y - b.radius*0.3, b.radius*0.1, b.x, b.y, b.radius);
            grad.addColorStop(0, "rgba(255, 255, 255, 0.6)");
            grad.addColorStop(1, "rgba(255, 255, 255, 0.1)");
            ctx.fillStyle = grad;
            ctx.strokeStyle = "rgba(255, 255, 255, 0.4)";
            ctx.lineWidth = 2;
            ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Usuwanie bąbelków poza ekranem
            if (b.y < -50) bubbles.splice(i, 1);
        }

        // Rysowanie efektu pękania
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.05;

            if (p.life <= 0) {
                particles.splice(i, 1);
                continue;
            }

            ctx.beginPath();
            ctx.fillStyle = `rgba(255, 255, 255, ${p.life})`;
            ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        if (Math.random() < 0.05) createBubble();

        requestAnimationFrame(draw);
    }

    draw();
</script>

</body>
</html>
