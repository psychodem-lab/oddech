<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>9x9 Block Master Pro</title>
    <style>
        :root {
            --bg-color: #121212;
            --board-bg: #1e1e24;
            --cell-empty: #2a2a35;
            --cell-filled: #4ecca3;
            --cell-ghost: rgba(78, 204, 163, 0.25);
            --text-color: #eeeeee;
            --gap: 4px;
            --cell-size: 40px;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', system-ui, sans-serif;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            min-height: 100vh; margin: 0; overflow: hidden; touch-action: none;
        }

        .header { display: flex; gap: 20px; align-items: center; margin-bottom: 10px; }
        .score-box { font-size: 2rem; font-weight: 800; color: var(--cell-filled); }
        
        /* PLANSZA Z SEKCJAMI 3x3 */
        .game-board {
            display: grid;
            grid-template-columns: repeat(9, var(--cell-size));
            grid-template-rows: repeat(9, var(--cell-size));
            gap: var(--gap);
            background-color: #000;
            padding: 8px; border-radius: 12px;
            position: relative;
        }

        .cell {
            width: 100%; height: 100%;
            background-color: var(--cell-empty);
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        /* Pod≈õwietlenie kwadrat√≥w 3x3 */
        .cell:nth-child(n+1):nth-child(-n+3), .cell:nth-child(n+10):nth-child(-n+12), .cell:nth-child(n+19):nth-child(-n+21),
        .cell:nth-child(n+7):nth-child(-n+9), .cell:nth-child(n+16):nth-child(-n+18), .cell:nth-child(n+25):nth-child(-n+27),
        .cell:nth-child(n+31):nth-child(-n+33), .cell:nth-child(n+40):nth-child(-n+42), .cell:nth-child(n+49):nth-child(-n+51),
        .cell:nth-child(n+34):nth-child(-n+36), .cell:nth-child(n+43):nth-child(-n+45), .cell:nth-child(n+52):nth-child(-n+54),
        .cell:nth-child(n+55):nth-child(-n+57), .cell:nth-child(n+64):nth-child(-n+66), .cell:nth-child(n+73):nth-child(-n+75),
        .cell:nth-child(n+61):nth-child(-n+63), .cell:nth-child(n+70):nth-child(-n+72), .cell:nth-child(n+79):nth-child(-n+81),
        .cell:nth-child(n+37):nth-child(-n+39), .cell:nth-child(n+46):nth-child(-n+48), .cell:nth-child(n+55):nth-child(-n+57)
        { background-color: #323240; }

        .cell.filled { background-color: var(--cell-filled); box-shadow: 0 0 8px var(--cell-filled); }
        .cell.ghost { background-color: var(--cell-ghost); border: 1px solid var(--cell-filled); }

        /* DOLNY PANEL (Hold + Pieces + Controls) */
        .bottom-panel {
            display: flex; align-items: center; gap: 15px; margin-top: 20px; width: 95%; max-width: 500px;
        }

        .hold-slot {
            width: calc(var(--cell-size) * 3); height: calc(var(--cell-size) * 3);
            background: rgba(255,255,255,0.05); border: 2px dashed #444;
            border-radius: 10px; display: flex; align-items: center; justify-content: center;
            position: relative;
        }
        .hold-slot::before { content: "HOLD"; position: absolute; bottom: -20px; font-size: 10px; color: #666; }

        .pieces-container {
            flex-grow: 1; display: flex; justify-content: center; gap: 15px; min-height: 120px;
        }

        .draggable-piece {
            display: grid; gap: 2px; cursor: grab; transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .piece-cell { width: var(--cell-size); height: var(--cell-size); background: var(--cell-filled); border-radius: 4px; }

        .controls { display: flex; flex-direction: column; gap: 10px; }
        .btn-small {
            background: #333; border: none; color: white; padding: 10px; border-radius: 8px; cursor: pointer; font-size: 12px;
        }
        .btn-small:disabled { opacity: 0.3; }

        /* PARTICLES */
        .particle {
            position: absolute; pointer-events: none; background: var(--cell-filled);
            border-radius: 50%; z-index: 100;
        }

        #game-over {
            position: fixed; inset: 0; background: rgba(0,0,0,0.9);
            display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 3000;
        }

        @media (max-width: 500px) {
            :root { --cell-size: calc((100vw - 80px) / 9); }
            .bottom-panel { flex-direction: column; }
            .pieces-container { min-height: 100px; }
        }
    </style>
</head>
<body>

    <div class="header">
        <div id="score-display" class="score-box">0</div>
        <button class="btn-small" onclick="shareScore()">üì§ Udostƒôpnij</button>
    </div>

    <div class="game-board" id="board"></div>

    <div class="bottom-panel">
        <div class="hold-slot" id="hold-slot"></div>
        <div class="pieces-container" id="pieces-dock"></div>
        <div class="controls">
            <button class="btn-small" id="undo-btn" onclick="undoMove()">‚Ü©Ô∏è Cofnij</button>
            <button class="btn-small" id="refresh-btn" onclick="refreshPieces()">‚ôªÔ∏è Nowe (1)</button>
        </div>
    </div>

    <div id="game-over">
        <h1 style="color:var(--cell-filled)">KONIEC GRY</h1>
        <p id="final-score">Wynik: 0</p>
        <button onclick="location.reload()" style="padding:15px 30px; border-radius:20px; border:none; background:var(--cell-filled); font-weight:bold;">Zagraj ponownie</button>
    </div>

<script>
    const BOARD_SIZE = 9;
    let boardState = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
    let lastState = null;
    let score = 0;
    let refreshesLeft = 1;
    let holdPiece = null;
    
    // Generator pseudo-losowy oparty na dacie (Daily Challenge)
    const today = new Date().toISOString().slice(0,10).replace(/-/g,"");
    let seed = parseInt(today);
    function seededRandom() {
        seed = (seed * 9301 + 49297) % 233280;
        return seed / 233280;
    }

    const SHAPES = [
        [[1]], [[1,1]], [[1,1,1]], [[1,1],[1,1]], [[1,1,1],[0,1,0]], 
        [[1,0],[1,0],[1,1]], [[1,1,1,1]], [[1,1,1],[1,0,0],[1,0,0]], [[0,1,1],[1,1,0]]
    ];

    const boardEl = document.getElementById('board');
    const dockEl = document.getElementById('pieces-dock');
    const holdEl = document.getElementById('hold-slot');

    function init() {
        renderBoard();
        spawnPieces();
        updateUI();
    }

    function renderBoard() {
        boardEl.innerHTML = '';
        boardState.forEach((row, y) => {
            row.forEach((val, x) => {
                const cell = document.createElement('div');
                cell.className = 'cell' + (val ? ' filled' : '');
                cell.dataset.coord = `${x},${y}`;
                boardEl.appendChild(cell);
            });
        });
    }

    // Rotacja macierzy o 90 stopni (nr 4)
    function rotateMatrix(matrix) {
        return matrix[0].map((_, i) => matrix.map(row => row[i]).reverse());
    }

    function spawnPieces() {
        dockEl.innerHTML = '';
        for (let i = 0; i < 3; i++) {
            const shape = SHAPES[Math.floor(seededRandom() * SHAPES.length)];
            addPieceToContainer(shape, dockEl);
        }
    }

    function addPieceToContainer(matrix, container, isHold = false) {
        const piece = document.createElement('div');
        piece.className = 'draggable-piece';
        piece.style.gridTemplateColumns = `repeat(${matrix[0].length}, var(--cell-size))`;
        
        matrix.forEach(row => row.forEach(v => {
            const c = document.createElement('div');
            if(v) c.className = 'piece-cell';
            piece.appendChild(c);
        }));

        // Klikniƒôcie - Rotacja (nr 4)
        piece.onclick = () => {
            if (isDragging) return;
            const rotated = rotateMatrix(matrix);
            const parent = piece.parentElement;
            piece.remove();
            addPieceToContainer(rotated, parent, isHold);
        };

        setupDrag(piece, matrix);
        container.appendChild(piece);
    }

    let isDragging = false;
    function setupDrag(el, matrix) {
        let startX, startY, rect;
        
        const move = (e) => {
            if(!isDragging) return;
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            el.style.left = (cx - startX) + 'px';
            el.style.top = (cy - startY) + 'px';

            clearGhosts();
            const g = getGridPos(el);
            if(canPlace(matrix, g.x, g.y)) showGhost(matrix, g.x, g.y);
        };

        const stop = (e) => {
            if(!isDragging) return;
            isDragging = false;
            document.removeEventListener('mousemove', move);
            document.removeEventListener('touchmove', move);
            clearGhosts();

            const g = getGridPos(el);
            const hRect = holdEl.getBoundingClientRect();
            const cx = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
            const cy = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;

            // Logika HOLD (nr 5)
            if(cx > hRect.left && cx < hRect.right && cy > hRect.top && cy < hRect.bottom) {
                if(!holdPiece) {
                    holdPiece = matrix;
                    el.remove();
                    addPieceToContainer(matrix, holdEl, true);
                    if(dockEl.children.length === 0) spawnPieces();
                    return;
                }
            }

            if(canPlace(matrix, g.x, g.y)) {
                saveState();
                placePiece(matrix, g.x, g.y);
                el.remove();
                checkLogic();
            } else {
                el.style.position = 'static';
            }
        };

        el.onmousedown = el.ontouchstart = (e) => {
            isDragging = true;
            rect = el.getBoundingClientRect();
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            startX = cx - rect.left;
            startY = cy - rect.top;
            el.style.position = 'fixed';
            el.style.width = rect.width + 'px';
            document.addEventListener('mousemove', move);
            document.addEventListener('touchmove', move, {passive:false});
            document.addEventListener('mouseup', stop, {once:true});
            document.addEventListener('touchend', stop, {once:true});
        };
    }

    function getGridPos(el) {
        const b = boardEl.getBoundingClientRect();
        const r = el.getBoundingClientRect();
        const cs = b.width / 9;
        return {
            x: Math.round((r.left - b.left) / cs),
            y: Math.round((r.top - b.top) / cs)
        };
    }

    function canPlace(m, sx, sy) {
        let ok = true;
        m.forEach((row, y) => row.forEach((v, x) => {
            if(v) {
                const bx = sx + x, by = sy + y;
                if(bx < 0 || bx >= 9 || by < 0 || by >= 9 || boardState[by][bx]) ok = false;
            }
        }));
        return ok;
    }

    function placePiece(m, sx, sy) {
        m.forEach((row, y) => row.forEach((v, x) => {
            if(v) boardState[sy+y][sx+x] = 1;
        }));
        renderBoard();
        score += 10;
        updateUI();
    }

    // Mechanika czyszczenia: Linie + Kwadraty 3x3 (nr 3)
    function checkLogic() {
        let toClear = new Set();
        // Linie
        for(let i=0; i<9; i++) {
            if(boardState[i].every(v => v)) for(let x=0; x<9; x++) toClear.add(`${x},${i}`);
            if(boardState.every(r => r[i])) for(let y=0; y<9; y++) toClear.add(`${i},${y}`);
        }
        // Kwadraty 3x3
        for(let r=0; r<3; r++) {
            for(let c=0; c<3; c++) {
                let full = true;
                for(let y=r*3; y<r*3+3; y++) {
                    for(let x=c*3; x<c*3+3; x++) if(!boardState[y][x]) full = false;
                }
                if(full) {
                    for(let y=r*3; y<r*3+3; y++) {
                        for(let x=c*3; x<c*3+3; x++) toClear.add(`${x},${y}`);
                    }
                }
            }
        }

        if(toClear.size > 0) {
            toClear.forEach(coord => {
                const [x,y] = coord.split(',').map(Number);
                createParticles(x, y);
                boardState[y][x] = 0;
            });
            score += toClear.size * 2;
            setTimeout(renderBoard, 300);
        }
        if(dockEl.children.length === 0) spawnPieces();
        updateUI();
    }

    function createParticles(x, y) {
        const b = boardEl.getBoundingClientRect();
        const cs = b.width / 9;
        for(let i=0; i<5; i++) {
            const p = document.createElement('div');
            p.className = 'particle';
            p.style.width = p.style.height = Math.random() * 8 + 4 + 'px';
            p.style.left = b.left + (x * cs) + cs/2 + 'px';
            p.style.top = b.top + (y * cs) + cs/2 + 'px';
            document.body.appendChild(p);
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.random() * 50 + 20;
            p.animate([
                { transform: 'translate(0,0) scale(1)', opacity: 1 },
                { transform: `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px) scale(0)`, opacity: 0 }
            ], { duration: 500, easing: 'ease-out' }).onfinish = () => p.remove();
        }
    }

    function saveState() { lastState = JSON.stringify({b: boardState, s: score}); }
    function undoMove() {
        if(!lastState) return;
        const data = JSON.parse(lastState);
        boardState = data.b; score = data.s;
        lastState = null; renderBoard(); updateUI();
    }

    function refreshPieces() {
        if(refreshesLeft > 0) {
            spawnPieces(); refreshesLeft--; updateUI();
        }
    }

    function shareScore() {
        const text = `Zdobylem ${score} punkt√≥w w Block Master! üß© #DailyChallenge`;
        navigator.clipboard.writeText(text);
        alert("Wynik skopiowany do schowka!");
    }

    function updateUI() {
        document.getElementById('score-display').innerText = score;
        document.getElementById('undo-btn').disabled = !lastState;
        document.getElementById('refresh-btn').innerText = `‚ôªÔ∏è Nowe (${refreshesLeft})`;
        document.getElementById('refresh-btn').disabled = refreshesLeft <= 0;
    }

    function showGhost(m, sx, sy) {
        m.forEach((row, y) => row.forEach((v, x) => {
            if(v) {
                const el = document.querySelector(`[data-coord="${sx+x},${sy+y}"]`);
                if(el) el.classList.add('ghost');
            }
        }));
    }
    function clearGhosts() { document.querySelectorAll('.cell.ghost').forEach(c => c.classList.remove('ghost')); }

    init();
</script>
</body>
</html>
