<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Trening oddechowy — presety i tryb wibracji</title>
<link rel="shortcut icon" type="image/png" href="favicon.png" />
<style>
:root{
  --bg:#f0f4f8; --card:#fff; --accent:#4a90e2; --success:#2ecc71; --danger:#e74c3c;
  --mute:#f39c12; --text:#222; --radius:12px; --shadow:0 3px 10px rgba(0,0,0,0.08);
}
*{box-sizing:border-box}
body{
  margin:0; padding:18px; font-family:Inter,Segoe UI, system-ui, sans-serif;
  background:var(--bg); color:var(--text); display:flex; flex-direction:column; align-items:center;
  min-height:100vh;
}
.app{
  width:100%; max-width:980px; display:flex; gap:18px; justify-content:center; flex-wrap:wrap;
}
.visual{
  width:320px; background:var(--card); border-radius:var(--radius); padding:18px; box-shadow:var(--shadow);
  display:flex; flex-direction:column; align-items:center; gap:12px;
}
.visual-container{ width:280px; height:280px; position:relative; display:flex; align-items:center; justify-content:center; }
.circle{
  width:140px; height:140px; background:var(--accent); border-radius:50%; box-shadow:0 0 25px rgba(74,144,226,0.35);
  transform:scale(1); transition:transform 600ms ease-in-out; z-index:1; opacity:0.95;
}
.instruction{
  position:relative; z-index:2; color:white; font-weight:700; text-shadow:0 2px 6px rgba(0,0,0,0.25);
  font-size:1.25rem; pointer-events:none;
}
.controls{
  width:320px; background:var(--card); border-radius:var(--radius); padding:16px; box-shadow:var(--shadow);
  display:flex; flex-direction:column; gap:12px;
}
.grid{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
.input{ display:flex; flex-direction:column; align-items:center; }
.input label{ font-size:0.82rem; color:#666; margin-bottom:6px; text-align:center; }
.input input{ width:100%; max-width:140px; padding:8px; border-radius:8px; border:1px solid #ddd; text-align:center; }
.controls-row{ display:flex; gap:8px; }
button{ padding:10px; border-radius:8px; border:none; font-weight:700; cursor:pointer; }
#start{ background:var(--success); color:#fff; flex:1 }
#stop{ background:var(--danger); color:#fff; flex:1 }
select,input[type="radio"]{ padding:8px; border-radius:8px; border:1px solid #ddd; }
.mode-row{ display:flex; gap:8px; align-items:center; }
.small{ font-size:0.9rem; color:#666 }
@media (max-width:700px){
  .visual,.controls{ width:100%; max-width:420px; }
  .visual-container{ width:220px; height:220px; }
  .circle{ width:110px; height:110px; }
}
</style>
</head>
<body>
  <h1 style="margin:0 0 12px 0;font-size:1.05rem;">Trening oddechowy — presety i tryb wibracji</h1>

  <div class="app" role="application" aria-label="Trening oddechowy">
    <section class="visual" aria-labelledby="visTitle">
      <div id="visTitle" style="display:none">Wizualizacja</div>
      <div class="visual-container" aria-hidden="false">
        <div class="circle" id="circle" aria-hidden="true"></div>
        <div class="instruction" id="instruction">Gotowy?</div>
      </div>
      <div class="small">Wizualizacja + efekt dźwiękowy / wibracyjny przy starcie faz.</div>
    </section>

    <aside class="controls" aria-labelledby="controlsTitle">
      <h2 id="controlsTitle" style="margin:0;font-size:0.95rem;">Sterowanie</h2>

      <div style="display:flex;gap:8px;align-items:center;">
        <label for="preset">Preset:</label>
        <select id="preset" aria-label="Wybierz preset">
          <option value="custom">Custom</option>
          <option value="box">Box 4-4-4-4</option>
          <option value="4262">4-2-6-2</option>
        </select>
        <div style="margin-left:auto;font-size:0.85rem;color:#666">Presety wypełniają pola (edycja przełącza na Custom)</div>
      </div>

      <div class="grid">
        <div class="input">
          <label for="inhale">Wdech (s)</label>
          <input id="inhale" type="number" value="4" min="0.1" step="0.1" />
        </div>
        <div class="input">
          <label for="hold1">Zatrzymaj 1 (s)</label>
          <input id="hold1" type="number" value="2" min="0" step="0.1" />
        </div>
        <div class="input">
          <label for="exhale">Wydech (s)</label>
          <input id="exhale" type="number" value="4" min="0.1" step="0.1" />
        </div>
        <div class="input">
          <label for="hold2">Zatrzymaj 2 (s)</label>
          <input id="hold2" type="number" value="4" min="0" step="0.1" />
        </div>
        <div class="input" style="grid-column:span 2;">
          <label for="total">Czas treningu (min)</label>
          <input id="total" type="number" value="2" min="0.5" step="0.5" />
        </div>
      </div>

      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div class="small">Czas do końca: <strong id="timer">00:00</strong></div>
        <div class="small" id="vib-support"></div>
      </div>

      <div class="controls-row" style="margin-top:8px;">
        <button id="start">Start</button>
        <button id="stop" disabled>Stop</button>
      </div>

      <div style="margin-top:8px;">
        <div class="small" style="margin-bottom:6px;">Tryb efektów:</div>
        <div class="mode-row" role="radiogroup" aria-label="Tryb efektów">
          <label><input type="radio" name="mode" value="sound" checked /> Dźwięk</label>
          <label><input type="radio" name="mode" value="vibration" /> Wibracja</label>
          <label><input type="radio" name="mode" value="silent" /> Cichy</label>
        </div>
      </div>

    </aside>
  </div>

<script>
/* Ulepszony skrypt:
 - Presety: wypełniają pola; edycja pól -> preset=custom (opcja C)
 - Tryby: sound / vibration / silent
 - Vibration API: wykrywanie wsparcia + użycie przy starcie faz
 - Web Audio: tworzenie i czyszczenie oscillatorów, cancelScheduledValues()
*/

'use strict';

/* DOM */
const presetSel = document.getElementById('preset');
const inhaleIn = document.getElementById('inhale');
const hold1In = document.getElementById('hold1');
const exhaleIn = document.getElementById('exhale');
const hold2In = document.getElementById('hold2');
const totalIn = document.getElementById('total');
const startBtn = document.getElementById('start');
const stopBtn = document.getElementById('stop');
const timerEl = document.getElementById('timer');
const instruction = document.getElementById('instruction');
const circle = document.getElementById('circle');
const vibSupportEl = document.getElementById('vib-support');
const modeRadios = document.querySelectorAll('input[name="mode"]');

let audioContext = null, oscillator = null, gainNode = null;
let isRunning = false;
let remainingMs = 0;
let sessionInterval = null;
let isMuted = false; // not used directly; mode controls behavior

/* Sound defaults */
const FREQ_START = 164.8;
const FREQ_END = 329.6;
const VOLUME_MAX = 0.28;

/* Presets */
const PRESETS = {
  box: { inhale:4, hold1:4, exhale:4, hold2:4 },
  '4262': { inhale:4, hold1:2, exhale:6, hold2:2 }
};

/* Vibration support */
const hasVibration = 'vibrate' in navigator;
vibSupportEl.innerText = hasVibration ? 'Wibracja dostępna' : 'Wibracja niedostępna';

/* Utility */
const wait = ms => new Promise(resolve => setTimeout(resolve, ms));
function ms(n){ return Math.round(n*1000); }

/* Preset handling: preset fills fields; editing fields -> preset = custom */
presetSel.addEventListener('change', () => {
  const v = presetSel.value;
  if (v === 'custom') return;
  const p = PRESETS[v];
  if (!p) return;
  inhaleIn.value = p.inhale;
  hold1In.value = p.hold1;
  exhaleIn.value = p.exhale;
  hold2In.value = p.hold2;
  // total left intact
});

/* If user edits any input, switch preset to custom */
[in inhaleIn, hold1In, exhaleIn, hold2In, totalIn].forEach?.(x=>{}); // placeholder to satisfy some linters
[in inhaleIn, hold1In, exhaleIn, hold2In, totalIn].forEach(input => {
  input.addEventListener('input', () => {
    if (presetSel.value !== 'custom') presetSel.value = 'custom';
  });
});

/* Audio helpers */
async function ensureAudioContext(){
  if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
  else if (audioContext.state === 'suspended') {
    try { await audioContext.resume(); } catch(e){ console.warn('resume failed', e); }
  }
  return audioContext;
}
function createOscAndGain(){
  if (!audioContext) throw new Error('no audio context');
  const osc = audioContext.createOscillator();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(FREQ_START, audioContext.currentTime);
  const gain = audioContext.createGain();
  gain.gain.setValueAtTime(0, audioContext.currentTime);
  osc.connect(gain);
  gain.connect(audioContext.destination);
  return {osc,gain};
}
function safeCancelScheduled(param){
  try {
    param.cancelScheduledValues(audioContext.currentTime);
  } catch(e){
    try { param.cancelAndHoldAtTime?.(audioContext.currentTime); } catch(e2){}
  }
}
function setVolume(target, durS=0.2){
  if (!gainNode) return;
  const t = audioContext.currentTime;
  safeCancelScheduled(gainNode.gain);
  try {
    gainNode.gain.setValueAtTime(gainNode.gain.value, t);
  } catch(e){}
  gainNode.gain.linearRampToValueAtTime(target, t + durS);
}
function transitionFreq(target, durMs=0){
  if (!oscillator) return;
  const durS = durMs/1000;
  const t = audioContext.currentTime;
  safeCancelScheduled(oscillator.frequency);
  try {
    oscillator.frequency.setValueAtTime(oscillator.frequency.value, t);
  } catch(e){}
  if (durS>0) oscillator.frequency.linearRampToValueAtTime(target, t + durS);
  else oscillator.frequency.setValueAtTime(target, t);
}

/* Start/stop sound */
async function startSoundIfNeeded(){
  const mode = getMode();
  if (mode !== 'sound') return;
  await ensureAudioContext();
  // cleanup existing nodes if any
  try { if (oscillator) { oscillator.stop(); oscillator.disconnect(); } } catch(e){}
  try { if (gainNode) gainNode.disconnect(); } catch(e){}
  const nodes = createOscAndGain();
  oscillator = nodes.osc; gainNode = nodes.gain;
  oscillator.start();
  setVolume(VOLUME_MAX, 0.15);
  transitionFreq(FREQ_START,0);
}
async function stopSoundCleanup(){
  if (!audioContext) return;
  try {
    if (gainNode) {
      setVolume(0,0.15);
      await wait(200);
    }
    if (oscillator) {
      try { oscillator.stop(); } catch(e){}
      try { oscillator.disconnect(); } catch(e){}
      oscillator = null;
    }
    if (gainNode) { try { gainNode.disconnect(); } catch(e){} gainNode=null; }
    if (audioContext && typeof audioContext.close === 'function') {
      await audioContext.close();
    }
  } catch(e){ console.warn('cleanup err', e); }
  finally{ audioContext = null; oscillator=null; gainNode=null; }
}

/* Vibration helper:
   During each phase we vibrate shortly if mode==='vibration' and device supports it.
   We'll vibrate a small pulse at phase start to signal transition.
*/
function vibratePulseForPhase(phase, durationMs){
  if (getMode() !== 'vibration') return;
  if (!hasVibration) return;
  // customize pulse length by phase
  const map = { inhale:120, hold:70, exhale:120 };
  const dur = map[phase] ?? 80;
  try { navigator.vibrate(dur); } catch(e){ /* ignore */ }
}

/* Mode helper */
function getMode(){
  const checked = document.querySelector('input[name="mode"]:checked');
  return checked ? checked.value : 'sound';
}
function handleModeChange(){
  const mode = getMode();
  if (mode === 'sound') {
    // if we are running, ensure audio is active
    if (isRunning) startSoundIfNeeded().catch(()=>{});
  } else {
    // if switching away from sound, stop audio nodes to save resources
    stopSoundCleanup().catch(()=>{});
  }
}
modeRadios.forEach(r=>r.addEventListener('change', handleModeChange));

/* Timer display */
function updateTimerDisplay(msLeft){
  const totalSeconds = Math.max(0, Math.floor(msLeft/1000));
  const minutes = Math.floor(totalSeconds/60);
  const seconds = totalSeconds % 60;
  timerEl.textContent = String(minutes).padStart(2,'0') + ':' + String(seconds).padStart(2,'0');
}

/* Reflow helper */
function forceReflow(el){ void el.offsetHeight; }

/* Validate inputs */
function validate(inhale,hold1,exhale,hold2,totalMin){
  if (!isFinite(inhale) || inhale <= 0) return 'Wdech musi być większy niż 0.';
  if (!isFinite(exhale) || exhale <= 0) return 'Wydech musi być większy niż 0.';
  if (!isFinite(totalMin) || totalMin < 0.5) return 'Czas treningu musi być co najmniej 0.5 minuty.';
  if (hold1 < 0 || hold2 < 0) return 'Czasy zatrzymania nie mogą być ujemne.';
  return null;
}

/* Main breathing loop */
async function breathingLoop(inhaleMs, hold1Ms, exhaleMs, hold2Ms){
  while (isRunning && remainingMs > 0){
    // INHALE
    instruction.textContent = 'Wdech';
    circle.style.transition = `transform ${inhaleMs}ms ease-in-out`;
    forceReflow(circle);
    circle.style.transform = 'scale(2)';
    if (getMode() === 'sound') transitionFreq(FREQ_END, inhaleMs);
    vibratePulseForPhase('inhale', inhaleMs);
    if (getMode() === 'sound') setVolume(VOLUME_MAX, 0.1);
    await wait(inhaleMs);
    if (!isRunning) break;

    // HOLD1
    if (hold1Ms > 0){
      instruction.textContent = 'Zatrzymaj';
      circle.style.transition = 'none';
      if (getMode() === 'sound') transitionFreq(FREQ_END, 0);
      if (getMode() === 'sound') setVolume(0, 0.05);
      vibratePulseForPhase('hold', hold1Ms);
      await wait(hold1Ms);
      if (!isRunning) break;
    }

    // EXHALE
    instruction.textContent = 'Wydech';
    circle.style.transition = `transform ${exhaleMs}ms ease-in-out`;
    forceReflow(circle);
    circle.style.transform = 'scale(1)';
    if (getMode() === 'sound') transitionFreq(FREQ_START, exhaleMs);
    vibratePulseForPhase('exhale', exhaleMs);
    if (getMode() === 'sound') setVolume(VOLUME_MAX, 0.1);
    await wait(exhaleMs);
    if (!isRunning) break;

    // HOLD2
    if (hold2Ms > 0){
      instruction.textContent = 'Zatrzymaj';
      circle.style.transition = 'none';
      if (getMode() === 'sound') transitionFreq(FREQ_START, 0);
      if (getMode() === 'sound') setVolume(0, 0.05);
      vibratePulseForPhase('hold', hold2Ms);
      await wait(hold2Ms);
      if (!isRunning) break;
    }
  }
}

/* Start/Stop handlers */
async function startSession(){
  if (isRunning) return;

  const inhale = parseFloat(inhaleIn.value);
  const hold1 = parseFloat(hold1In.value);
  const exhale = parseFloat(exhaleIn.value);
  const hold2 = parseFloat(hold2In.value);
  const totalMin = parseFloat(totalIn.value);

  const err = validate(inhale, hold1, exhale, hold2, totalMin);
  if (err){ alert(err); return; }

  const inhaleMs = ms(inhale), hold1Ms = ms(hold1), exhaleMs = ms(exhale), hold2Ms = ms(hold2);
  remainingMs = Math.round(totalMin * 60 * 1000);

  isRunning = true;
  startBtn.disabled = true;
  stopBtn.disabled = false;
  // disable inputs except preset selection & mode (user can still change preset -> becomes custom)
  [inhaleIn,hold1In,exhaleIn,hold2In,totalIn].forEach(i=>i.disabled=true);

  instruction.textContent = 'Rozpoczynam...';
  updateTimerDisplay(remainingMs);

  // prepare audio if needed
  try { await startSoundIfNeeded(); } catch(e){ console.warn('sound start failed', e); }

  // session countdown
  sessionInterval = setInterval(()=>{
    remainingMs -= 1000;
    if (remainingMs < 0) remainingMs = 0;
    updateTimerDisplay(remainingMs);
    if (remainingMs <= 0){
      clearInterval(sessionInterval); sessionInterval = null;
      stopSession('Trening zakończony! Dobra robota!');
    }
  },1000);

  // run loop
  try {
    await breathingLoop(inhaleMs, hold1Ms, exhaleMs, hold2Ms);
  } catch (e){ console.error('loop error', e); }

  // if finished normally and still running => stop
  if (isRunning) await stopSession('Gotowy?');
}

async function stopSession(finalText='Gotowy?'){
  if (!isRunning){
    // ensure audio cleaned up
    await stopSoundCleanup();
    instruction.textContent = finalText;
    updateTimerDisplay(0);
    return;
  }
  isRunning = false;
  startBtn.disabled = false;
  stopBtn.disabled = true;
  if (sessionInterval){ clearInterval(sessionInterval); sessionInterval=null; }
  instruction.textContent = finalText;
  circle.style.transition = 'transform 450ms ease-out';
  forceReflow(circle);
  circle.style.transform = 'scale(1)';

  await stopSoundCleanup();

  // re-enable inputs
  [inhaleIn,hold1In,exhaleIn,hold2In,totalIn].forEach(i=>i.disabled=false);
  updateTimerDisplay(0);
}

/* UI binding */
startBtn.addEventListener('click', ()=>startSession().catch(e=>console.error(e)));
stopBtn.addEventListener('click', ()=>stopSession('Gotowy?').catch(e=>console.error(e)));
presetSel.addEventListener('change', ()=>{ /* handled above */ });

// if user edits -> preset->custom (already added)
[in inhaleIn, hold1In, exhaleIn, hold2In, totalIn] = [inhaleIn, hold1In, exhaleIn, hold2In, totalIn]; // no-op to satisfy some linters

// keyboard: Enter start, Esc stop
document.addEventListener('keydown', (e)=>{
  if (e.key === 'Enter' && !startBtn.disabled) startBtn.click();
  if (e.key === 'Escape' && !stopBtn.disabled) stopBtn.click();
});

// init UI: set default preset to box for start? User said "na start 2." — we use 2 presets available and default to 'custom' with UI filled
(function init(){
  // Start with preset 'custom' but with values for Box 4-4-4-4 pre-filled to keep previous behavior:
  // The user requested start with 2 presets — we provide two options in dropdown; default leave as custom and keep current inputs.
  presetSel.value = 'custom';
  // show vibration support
  vibSupportEl.style.opacity = hasVibration ? '1' : '0.7';
})();

/* When mode changes mid-session, reflect immediate effect */
modeRadios.forEach(r => r.addEventListener('change', () => {
  handleModeChange();
}));

// ensure handleModeChange reflects initial mode
handleModeChange();
</script>
</body>
</html>
