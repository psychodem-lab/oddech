<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Akwarium Zen - Widok z boku</title>
    <style>
        body { 
            background: #050a0f; 
            margin: 0; 
            overflow: hidden; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh;
            font-family: sans-serif;
            touch-action: none;
        }
        canvas { 
            background: linear-gradient(to bottom, #1a364d 0%, #0a141d 100%);
            box-shadow: inset 0 0 100px rgba(0,0,0,0.5), 0 20px 50px rgba(0,0,0,0.8);
            border: 12px solid #2c3e50;
            border-radius: 10px;
            cursor: crosshair;
            max-width: 95vw;
            max-height: 85vh;
        }
        .instr { position: absolute; top: 20px; color: #5dade2; opacity: 0.6; pointer-events: none; }
    </style>
</head>
<body>

<div class="instr">Trzymaj palec, aby rybki do Ciebie podpłynęły</div>
<canvas id="fishCanvas" width="1000" height="600"></canvas>

<script>
    const canvas = document.getElementById("fishCanvas");
    const ctx = canvas.getContext("2d");

    let mouse = { x: -1000, y: -1000, down: false };
    let fishes = [];
    let plants = [];

    // Definicje gatunków
    const types = [
        { name: 'skalar', color: '#ecf0f1', accent: '#bdc3c7', size: 40 },
        { name: 'mieczyk', color: '#e67e22', accent: '#d35400', size: 35 },
        { name: 'molinezja', color: '#2c3e50', accent: '#000000', size: 30 },
        { name: 'gupik', color: '#9b59b6', accent: '#f1c40f', size: 20 }
    ];

    // Inicjalizacja roślin (wodorostów)
    for(let i=0; i<15; i++) {
        plants.push({
            x: Math.random() * canvas.width,
            h: 100 + Math.random() * 200,
            off: Math.random() * Math.PI * 2,
            speed: 0.02 + Math.random() * 0.03
        });
    }

    class Fish {
        constructor() {
            this.type = types[Math.floor(Math.random() * types.length)];
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.velX = (Math.random() - 0.5) * 2;
            this.velY = (Math.random() - 0.5) * 1;
            this.angle = 0;
            this.flip = 1; // 1 w prawo, -1 w lewo
        }

        update() {
            let tx = mouse.down ? mouse.x : this.x + this.velX * 100;
            let ty = mouse.down ? mouse.y : this.y + this.velY * 100;

            let dx = tx - this.x;
            let dy = ty - this.y;
            let dist = Math.sqrt(dx*dx + dy*dy);

            if (mouse.down && dist > 20) {
                this.velX += (dx / dist) * 0.05;
                this.velY += (dy / dist) * 0.05;
            } else {
                this.velX += (Math.random() - 0.5) * 0.02;
                this.velY += (Math.random() - 0.5) * 0.02;
            }

            // Opór wody
            this.velX *= 0.98;
            this.velY *= 0.98;

            this.x += this.velX;
            this.y += this.velY;

            // Odbijanie od ścian
            if (this.x < 50 || this.x > canvas.width - 50) this.velX *= -0.5;
            if (this.y < 50 || this.y > canvas.height - 50) this.velY *= -0.5;

            // Kierunek patrzenia
            if (this.velX > 0.1) this.flip = 1;
            if (this.velX < -0.1) this.flip = -1;
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.scale(this.flip, 1);
            
            const s = this.type.size;
            ctx.fillStyle = this.type.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = "rgba(0,0,0,0.3)";

            if (this.type.name === 'skalar') {
                // Kształt trójkątny skalara
                ctx.beginPath();
                ctx.moveTo(s, 0); // Pysk
                ctx.lineTo(-s, -s * 1.5); // Góra
                ctx.lineTo(-s * 0.5, 0); // Wcięcie
                ctx.lineTo(-s, s * 1.5); // Dół
                ctx.closePath();
                ctx.fill();
                // Płetwa boczna
                ctx.strokeStyle = this.type.accent;
                ctx.stroke();
            } else if (this.type.name === 'mieczyk') {
                // Smukłe ciało i miecz
                ctx.beginPath();
                ctx.ellipse(0, 0, s, s * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(-s, 0);
                ctx.lineTo(-s * 2.5, s * 0.6); // Miecz
                ctx.lineTo(-s * 0.8, s * 0.2);
                ctx.fillStyle = this.type.accent;
                ctx.fill();
            } else if (this.type.name === 'molinezja') {
                // Bardziej zaokrąglona
                ctx.beginPath();
                ctx.ellipse(0, 0, s, s * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(-s, 0);
                ctx.quadraticCurveTo(-s * 1.8, -s, -s * 1.8, s);
                ctx.closePath();
                ctx.fill();
            } else { // gupik
                ctx.beginPath();
                ctx.ellipse(0, 0, s, s * 0.4, 0, 0, Math.PI * 2);
                ctx.fill();
                // Wielki kolorowy ogon
                ctx.fillStyle = this.type.accent;
                ctx.beginPath();
                ctx.moveTo(-s * 0.8, 0);
                ctx.bezierCurveTo(-s*2, -s*1.5, -s*2, s*1.5, -s*0.8, 0);
                ctx.fill();
            }

            // Oko
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(s * 0.6, -s * 0.1, 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }
    }

    // Tworzenie rybek
    for(let i=0; i<12; i++) fishes.push(new Fish());

    function drawPlants() {
        const time = Date.now();
        ctx.strokeStyle = "#1e8449";
        ctx.lineWidth = 8;
        ctx.lineCap = "round";
        
        plants.forEach(p => {
            ctx.beginPath();
            ctx.moveTo(p.x, canvas.height);
            let sway = Math.sin(time * p.speed + p.off) * 20;
            ctx.bezierCurveTo(p.x + sway, canvas.height - p.h/2, p.x - sway, canvas.height - p.h, p.x, canvas.height - p.h);
            ctx.stroke();
        });
    }

    function animate() {
        // Tło - czyszczenie z lekkim smużeniem
        ctx.fillStyle = "rgba(26, 54, 77, 0.4)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        drawPlants();

        fishes.forEach(f => {
            f.update();
            f.draw();
        });

        // Bąbelki powietrza
        if (Math.random() < 0.05) {
            ctx.fillStyle = "rgba(255,255,255,0.2)";
            ctx.beginPath();
            ctx.arc(Math.random() * canvas.width, canvas.height, Math.random() * 5, 0, Math.PI*2);
            ctx.fill();
        }

        requestAnimationFrame(animate);
    }

    // Obsługa myszy i dotyku
    const setMouse = (e) => {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        mouse.x = (clientX - rect.left) * (canvas.width / rect.width);
        mouse.y = (clientY - rect.top) * (canvas.height / rect.height);
    };

    canvas.addEventListener('mousedown', (e) => { mouse.down = true; setMouse(e); });
    canvas.addEventListener('touchstart', (e) => { mouse.down = true; setMouse(e); });
    window.addEventListener('mouseup', () => mouse.down = false);
    window.addEventListener('touchend', () => mouse.down = false);
    canvas.addEventListener('mousemove', setMouse);
    canvas.addEventListener('touchmove', setMouse);

    animate();
</script>

</body>
</html>
